# План по приведению схемы БД к поддерживаемым миграциям

## 1. Текущее состояние

### 1.1 Фактическая схема в продакшене
- Основные таблицы (`areas`, `projects`, `tasks`, `resources`, `time_entries`) используют auto-increment `INTEGER` первичные ключи и внешние ключи на `INTEGER`/`BIGINT`.
- Таблица `time_entries` содержит колонки `start_time`, `end_time`, `owner_id` и **не содержит** `stopped_at`. Активные таймеры определяются по `end_time IS NULL`.
- Пользовательские таблицы (`users_web`) уже пополнены диагностическими полями `diagnostics_enabled`, `diagnostics_active`, `diagnostics_available` (SMALLINT[]).
- В базе созданы диагностические таблицы (`diagnostic_templates`, `diagnostic_clients`, `diagnostic_results`) и необходимые индексы.
- Дополнительные ограничения (`ux_roles_slug`, `uq_user_roles_assignment`, `ck_user_roles_scope`) добавлены вручную для корректной работы ролей.

### 1.2 DDL/миграции в репозитории
- Скрипты в `backend/db/ddl/*.sql` и `backend/db/migrations/*.sql` ориентированы на новую UUID-схему (`UUID`, `gen_random_uuid()`, индекс `WHERE stopped_at IS NULL`).
- При запуске bootstrap/repair (`DB_BOOTSTRAP=1`, `DB_REPAIR=1`) они выполняют несовместимые ALTER/INSERT, что приводит к падению сервиса.
- Системы версионирования миграций нет (`schema_migrations` отсутствует), применяется последовательность SQL-файлов без учёта зависимостей.

### 1.3 Временные ручные правки
- Колонки и таблицы диагностик добавлены через `psql`.
- Индекс активного таймера приведён к `ON time_entries(owner_id) WHERE end_time IS NULL`.
- В `.env` временно выставлены `DB_BOOTSTRAP=0` и `DB_REPAIR=0`, чтобы приложение стартовало на legacy-схеме.

## 2. Проблемы и риски
1. **Несогласованность моделей и БД**: SQLAlchemy-модели частично рассчитаны на актуальную integer-схему, а DDL — на UUID. Отсутствует единая “истина”.
2. **Bootstrap/repair**: при включении выполняют некорректный SQL и приводят к отказу сервиса.
3. **Отсутствие Alembic**: нет управляемых миграций с возможностью отката, аудитом и зависимостями.
4. **Тестовая среда**: pytest использует SQLite; миграции с PostgreSQL-спецификой (ENUM, JSONB, UUID) нужно адаптировать или переключить тесты на PostgreSQL.

## 3. Требования к новой миграционной системе
- Ввести Alembic (или аналог) с baseline-текущей схемы и дальнейшими ревизиями, обеспечив `upgrade`/`downgrade`.
- Сохранить возможность ручного применения SQL (текущее fallback-решение) до полной стабилизации Alembic.
- Решить, поддерживаем ли legacy INTEGER-схему как целевую или выполняем миграцию на UUID (требуются решения по конвертации PK/FK).
- Обеспечить библиотеку миграций, совместимую с prod данными, и аккуратный rollout (бэкапы, проверка).

## 4. Предлагаемый план
1. **Инвентаризация**
   - Сделать `pg_dump --schema-only` и сохранить как baseline (`reports/archive/schema_baseline_legacy.sql`).
   - Сравнить с моделями (`backend/models.py`) и DDL, перечислить отличия (тип PK, отсутствующие колонки, индексы).
2. **Инициализация Alembic**
   - Создать конфигурацию `alembic/`, настроить подключение через `backend.db.engine`.
   - Сгенерировать initial revision, отражающий текущее (legacy) состояние; установить флаг `branch_labels=()` и пометить ревизию как baseline.
3. **Миграции диагностики**
   - Формализовать добавленные вручную объекты (колонки, таблицы, индексы) в Alembic-ревизии, чтобы новые среды поднимались без ручных команд.
4. **Дальнейшие шаги**
   - Подготовить миграцию UUID (если принято) или обновить DDL на integer-схему.
   - Перенести bootstrap на Alembic (`alembic upgrade head`) вместо запуска `backend/db/ddl`.
   - Обновить repair-скрипты, чтобы они проверяли типы колонок или использовать управляемые фоновые задачи вместо прямого SQL.
5. **Верификация**
   - Завести тестовую PostgreSQL БД (docker-compose) и добавить в CI шаг `alembic upgrade head` + smoke-тест API.
   - Обновить pytest фикстуры (использовать асинхронный Postgres через testcontainers или `pytest-postgresql`).

## 5. Механизм отката / fallback
- Хранить текущие ручные SQL-патчи в `reports/archive/manual_db_patch.sql`, их можно повторно применить при аварийном восстановлении.
- До полной миграции оставляем `.env` флаги `DB_BOOTSTRAP=0`, `DB_REPAIR=0`; включение возможно после появления корректных Alembic-миграций.
- Перед каждым `upgrade` выполнять `pg_dump -Fc` и документировать процедуру восстановления.

## 6. Следующие действия (предлагаемые задачи)
1. Сформировать baseline-дамп legacy-схемы и разместить в репозитории.
2. Инициализировать Alembic, подготовить initial revision и интеграцию в процесс деплоя.
3. Перенести диагностические объекты в Alembic-ревизию.
4. Определиться с целевой моделью идентификаторов (INTEGER vs UUID) и подготовить план миграции.
5. Обновить тестовую инфраструктуру для запуска миграций на PostgreSQL.
